local Players = game:GetService("Players")
local player = Players.LocalPlayer

-- Biến
local running = true
local flight = { bp = nil, bg = nil, hrp = nil }
local lastOrbTime = 0
local HOVER_OFFSET = 50 -- Khoảng cách bay lơ lửng so với vị trí hiện tại
local hasHovered = false -- Kiểm tra xem đã thiết lập vị trí lơ lửng chưa

-- Attach BodyPosition + BodyGyro
local function attachFlight(hrp)
	if flight.bp then flight.bp:Destroy() end
	if flight.bg then flight.bg:Destroy() end
	flight.hrp = hrp

	flight.bp = Instance.new("BodyPosition")
	flight.bp.MaxForce = Vector3.new(1e5, 1e5, 1e5)
	flight.bp.P = 30000
	flight.bp.D = 1000
	flight.bp.Position = hrp.Position
	flight.bp.Parent = hrp

	flight.bg = Instance.new("BodyGyro")
	flight.bg.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
	flight.bg.P = 30000
	flight.bg.CFrame = hrp.CFrame
	flight.bg.Parent = hrp
end

local function detachFlight()
	if flight.bp then flight.bp:Destroy() end
	if flight.bg then flight.bg:Destroy() end
	flight.bp, flight.bg, flight.hrp = nil, nil, nil
	hasHovered = false
end

-- Lấy danh sách orb trong phạm vi gần
local function getOrbs()
	local container = workspace:FindFirstChild("OrbContainer_5370403716")
	local list = {}
	local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
	if not hrp or not container then return list end

	for _, child in ipairs(container:GetChildren()) do
		if child.Name == "ChainOrb" then
			local part = child.PrimaryPart or child:FindFirstChildWhichIsA("BasePart")
			if part and (part.Position - hrp.Position).Magnitude < 200 then
				table.insert(list, part)
			end
		end
	end
	return list
end

-- Tìm orb gần nhất
local function getClosestOrb()
	local orbs = getOrbs()
	if #orbs == 0 then return nil end

	local closestOrb = nil
	local closestDist = math.huge
	local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return nil end

	for _, orb in ipairs(orbs) do
		local dist = (orb.Position - hrp.Position).Magnitude
		if dist < closestDist then
			closestDist = dist
			closestOrb = orb
		end
	end

	return closestOrb
end

-- Di chuyển tới vị trí chỉ định
local function moveToTarget(pos, yLevel)
	if not flight.bp then return end
	local finalPos = Vector3.new(pos.X, yLevel, pos.Z)
	flight.bp.Position = finalPos
end

-- Auto Orb loop
local function runAuto()
	while running do
		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then hrp = player.CharacterAdded:Wait():WaitForChild("HumanoidRootPart") end
		
		local orb = getClosestOrb()
		if orb and orb.Parent then
			lastOrbTime = tick()
			if not flight.bp then
				attachFlight(hrp)
			end
			-- Lấy tọa độ Y của orb và bay cao hơn một chút
			moveToTarget(orb.Position, orb.Position.Y + 5)
			hasHovered = false -- Reset trạng thái lơ lửng
		else
			if flight.bp then
				if tick() - lastOrbTime > 3.4 then
					detachFlight()
				else
					if not hasHovered then
						-- Chỉ thiết lập vị trí bay lơ lửng một lần
						flight.bp.Position = Vector3.new(hrp.Position.X, hrp.Position.Y + HOVER_OFFSET, hrp.Position.Z)
						hasHovered = true
					end
					-- Duy trì vị trí đã thiết lập
					moveToTarget(hrp.Position, flight.bp.Position.Y)
				end
			end
		end
		task.wait(0.5)
	end
end

-- Bắt đầu chạy script
task.spawn(runAuto)

-- Khi respawn thì gắn lại flight nếu đang bật
player.CharacterAdded:Connect(function(char)
	if running then
		local hrp = char:WaitForChild("HumanoidRootPart")
		attachFlight(hrp)
	end
end)
